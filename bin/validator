#!/usr/bin/env python

'''
Validate layout of generated HTML pages.
(We validate the HTML because source may not be in Markdown.)
'''

import sys
import os
import glob
import fnmatch
import re
import yaml
from optparse import OptionParser
from bs4 import BeautifulSoup
from lxml import etree


# Default lesson configuration.
LESSON_CONFIG = '''\
patterns:
  '*.html':
    - lesson_has_title_in_head
    - lesson_has_navbar
    - lesson_has_title_in_body
    - lesson_has_footer
  index.html:
    - lesson_has_prereq
    - lesson_has_syllabus
  '*-*/index.html':
    - lesson_has_objectives
'''

# Default workshop configuration.
WORKSHOP_CONFIG = '''\
patterns:
  'index.html':
    - workshop_check_slug
    - workshop_check_dates
    - workshop_check_country
    - workshop_check_location
    - workshop_check_instructors
    - workshop_check_helpers
    - workshop_check_contact
    - workshop_check_eventbrite
'''


# Record all the rules.
RULES = {}
def rule(fn):
    RULES[fn.__name__] = fn
    return fn


def main():
    '''Main driver: check all files with all rules that apply.'''

    args = parse_args()
    read_config(args)
    docs = read_all_docs(args.source_dir)
    _require(docs, 'No source files found in {0}'.format(args.source_dir))
    all_filenames = docs.keys()
    for filename in all_filenames:
        if args.verbose > 0:
            print(filename, '...', file=sys.stderr)
        for pattern in args.patterns:
            full_pattern = os.path.join(args.source_dir, pattern)
            if fnmatch.fnmatch(filename, full_pattern):
                for rule in args.patterns[pattern]:
                    if args.verbose > 1:
                        print('...', rule, file=sys.stderr)
                    RULES[rule](filename, docs[filename])


def parse_args():
    '''Parse command-line arguments.'''

    parser = OptionParser()
    parser.add_option('-c', '--config',
                      default=None,
                      dest='config_file',
                      help='configuration file')
    parser.add_option('-l', '--lesson',
                      default=False,
                      action='store_true',
                      dest='check_lesson',
                      help='check a lesson')
    parser.add_option('-s', '--source',
                      default='_site',
                      dest='source_dir',
                      help='source directory')
    parser.add_option('-v', '--verbose',
                      default=0,
                      action='count',
                      dest='verbose',
                      help='report actions')
    parser.add_option('-w', '--workshop',
                      default=False,
                      action='store_true',
                      dest='check_workshop',
                      help='check a workshop')

    args, extras = parser.parse_args()

    _require(not extras, 'Unexpected trailing command-line arguments "{0}"'.format(extras))
    _require(args.check_lesson != args.check_workshop, 'Must have exactly one of -l/-w')

    return args


def read_config(args):
    '''
    Read configuration file.
    '''

    if args.config_file:
        with open(args.config_file, 'r') as reader:
            args.config = yaml.load(reader)
    elif args.check_lesson:
        args.config = yaml.load(LESSON_CONFIG)
    elif args.check_workshop:
        args.config = yaml.load(WORKSHOP_CONFIG)
    else:
        assert False, 'Do not know what configuration to load'

    args.patterns = args.config['patterns']


def read_all_docs(source_dir):
    '''
    Read all HTML pages under the source directory.
    Returns a dictionary of (path, doc).
    '''

    pattern = os.path.join(source_dir, '**/*.html')
    result = {}
    for path in glob.iglob(pattern, recursive=True):
        try:
            with open(path, 'r') as reader:
                raw = reader.read().replace('<!doctype html>\n', '')
                soup = BeautifulSoup(raw, 'html.parser').prettify()
                doc = etree.fromstring(soup)
                result[path] = doc
        except IOError as e:
            print('Unable to open {0}: {1}'.format(path, e), file=sys.stderr)
            sys.exit(1)

    return result


@rule
def lesson_has_footer(filename, doc):
    '''Document has footer element.'''

    _check_one_element(filename, doc, 'footers', '//footer')


@rule
def lesson_has_navbar(filename, doc):
    '''Document has header element.'''

    _check_one_element(filename, doc, 'div navbar', '//div[@class="navbar-header"]')


@rule
def lesson_has_objectives(filename, doc):
    '''Episode has objectives.'''

    _check_one_element(filename, doc, 'objectives div', '//blockquote[@class="objectives"]')


@rule
def lesson_has_prereq(filename, doc):
    '''Index page has prerequisites block.'''

    _check_one_element(filename, doc, 'prerequisites blockquote', '//blockquote[@class="prereq"]')


@rule
def lesson_has_syllabus(filename, doc):
    '''Index page has syllabus.'''

    _check_one_element(filename, doc, 'syllabus', '//div[@class="syllabus"]')
    _check_one_element(filename, doc, 'syllabus title', '//div[@class="syllabus"]/h2')
    _check_one_element(filename, doc, 'syllabus table', '//div[@class="syllabus"]/table')


@rule
def lesson_has_title_in_head(filename, doc):
    '''Document has a title in the head.'''

    _check_one_element(filename, doc, 'title in head', '//head//title')


@rule
def lesson_has_title_in_body(filename, doc):
    '''Document has a title in the body.'''

    _check_one_element(filename, doc, 'title in body', '//body//h1[@class="maintitle"]')


@rule
def workshop_check_slug(filename, doc):
    tag = 'has slug'
    content = _check_one_element(filename, doc, tag, '//html/head/meta[@name="slug"]', attribute='content')
    _check_regexp(filename, doc, tag, content, '.+')


@rule
def workshop_check_dates(filename, doc):
    pass


@rule
def workshop_check_country(filename, doc):
    pass


@rule
def workshop_check_location(filename, doc):
    pass


@rule
def workshop_check_instructors(filename, doc):
    pass


@rule
def workshop_check_helpers(filename, doc):
    pass


@rule
def workshop_check_contact(filename, doc):
    pass


@rule
def workshop_check_eventbrite(filename, doc):
    pass


def _check_one_element(filename, doc, rulename, xpath, attribute=None):
    '''Check that an equality holds.'''

    result = None
    actual = doc.xpath(xpath)
    if len(actual) != 1:
        print('In {0}, checking {1}: expected 1 match, got {2}'.format(filename, rulename, len(actual)))
    if attribute is not None:
        result = actual[0].attrib.get(attribute, None)
    return result


def _check_regexp(filename, doc, rulename, content, pattern):
    '''Check that text content matches pattern.'''

    if not re.match(pattern, content):
        print('In {0}, checking {1}: pattern "{2}" does not match value "{3}"'.format(filename, rulename, pattern, content))


def _require(condition, message):
    '''Fail if condition not met.'''

    if not condition:
        print(message, file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
